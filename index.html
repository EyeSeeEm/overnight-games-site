<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Library - Steam Style</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Motiva Sans", Arial, Helvetica, sans-serif;
      background: linear-gradient(to bottom, #1b2838 0%, #1b2838 100%);
      color: #c7d5e0;
      min-height: 100vh;
    }

    .header {
      background: linear-gradient(to bottom, #1e3a4c 0%, #171d25 100%);
      padding: 14px 24px;
      display: flex;
      align-items: center;
      gap: 24px;
      border-bottom: 2px solid #66c0f4;
      box-shadow: 0 2px 10px rgba(0,0,0,0.6);
    }
    .header h1 {
      color: #fff;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 3px;
      white-space: nowrap;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    .header h1 .version {
      font-size: 10px;
      color: #66c0f4;
      font-weight: 400;
      margin-left: 12px;
      letter-spacing: 1px;
      text-transform: none;
      opacity: 0.8;
    }
    .stats-bar {
      display: flex;
      gap: 6px;
      font-size: 12px;
      margin-left: auto;
      flex-wrap: wrap;
    }
    .stats-bar span {
      background: linear-gradient(to bottom, #2a475e, #1b2838);
      border: 1px solid #3d6c8a;
      padding: 6px 14px;
      border-radius: 2px;
      white-space: nowrap;
      color: #c6d4df;
      font-weight: 500;
      text-shadow: 0 1px 2px rgba(0,0,0,0.4);
    }
    .stats-bar span:hover {
      background: linear-gradient(to bottom, #3d6c8a, #2a475e);
      border-color: #66c0f4;
    }

    .controls {
      background: #16202d;
      padding: 12px 24px;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .control-group label {
      font-size: 11px;
      text-transform: uppercase;
      color: #8f98a0;
    }
    select, input[type="text"] {
      background: #316282;
      border: none;
      color: #fff;
      padding: 8px 12px;
      border-radius: 2px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    select:hover, input[type="text"]:hover {
      background: #417a9b;
    }
    select:focus, input[type="text"]:focus {
      outline: none;
      background: #4c8caf;
    }
    input[type="text"] {
      width: 200px;
    }
    input[type="text"]::placeholder {
      color: rgba(255,255,255,0.5);
    }

    .content {
      display: flex;
      min-height: calc(100vh - 120px);
    }

    .games-grid {
      flex: 1;
      padding: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(230px, 1fr));
      gap: 16px;
      align-content: start;
    }

    /* HOVER NOTE: NO transform/scale on hover - only border/highlight effects
       Desktop app style (Steam-like) - no size/position changes */
    .game-card {
      background: linear-gradient(to bottom, rgba(0,0,0,0.2), rgba(0,0,0,0.4));
      border-radius: 4px;
      overflow: hidden;
      transition: background 0.15s, box-shadow 0.15s, border-color 0.15s;
      cursor: pointer;
      position: relative;
      border: 1px solid transparent;
    }
    .game-card:hover {
      /* NO transform - only visual highlight like Steam */
      background: linear-gradient(to bottom, rgba(30,50,70,0.5), rgba(20,40,60,0.6));
      box-shadow: 0 0 10px rgba(103, 193, 245, 0.2);
      border-color: rgba(103, 193, 245, 0.4);
    }
    .game-card.played {
      opacity: 0.6;
    }
    .game-card.played:hover {
      opacity: 1;
    }
    .game-card.played::after {
      content: "PLAYED";
      position: absolute;
      top: 8px;
      right: 8px;
      background: #4c6b22;
      color: #a4d007;
      font-size: 9px;
      font-weight: bold;
      padding: 3px 6px;
      border-radius: 2px;
    }
    .game-card.updated::after {
      content: "UPDATED";
      position: absolute;
      top: 8px;
      right: 8px;
      background: #c97f00;
      color: #ffd700;
      font-size: 9px;
      font-weight: bold;
      padding: 3px 6px;
      border-radius: 2px;
    }
    /* Updated takes priority over played when both apply */
    .game-card.played.updated::after {
      content: "UPDATED";
      background: #c97f00;
      color: #ffd700;
    }

    /* Broken game overlay */
    .game-card.broken {
      opacity: 0.5;
    }
    .game-card.broken::before {
      content: "‚úï";
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      font-weight: bold;
      color: rgba(255, 50, 50, 0.8);
      z-index: 5;
      pointer-events: none;
      text-shadow: 0 0 15px rgba(0,0,0,0.8);
      -webkit-text-stroke: 3px rgba(180, 30, 30, 0.9);
    }
    .game-card.broken:hover {
      opacity: 0.8;
    }

    .screenshot {
      width: 100%;
      height: 108px;
      object-fit: cover;
      display: block;
    }
    .no-screenshot {
      width: 100%;
      height: 108px;
      background: linear-gradient(135deg, #1b2838, #2a475e);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4c6b8a;
      font-size: 32px;
    }

    .card-info {
      padding: 10px;
    }
    .game-title {
      font-size: 13px;
      color: #c7d5e0;
      margin-bottom: 6px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .game-tags {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }
    .tag {
      background: rgba(103, 193, 245, 0.1);
      color: #67c1f5;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 2px;
    }
    .tag.polished {
      background: rgba(164, 208, 7, 0.2);
      color: #a4d007;
    }
    .tag.framework {
      background: rgba(255,255,255,0.1);
      color: #8f98a0;
    }


    /* Notes indicator - hidden until hover */
    .notes-btn {
      position: absolute;
      top: 38px;
      left: 8px;
      background: rgba(0,0,0,0.7);
      border: none;
      color: #8f98a0;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      z-index: 10;
      transition: all 0.2s;
      opacity: 0;
    }
    .game-card:hover .notes-btn {
      opacity: 1;
    }
    .notes-btn:hover {
      background: #67c1f5;
      color: #fff;
    }
    .notes-btn.has-notes {
      background: #67c1f5;
      color: #fff;
      opacity: 1;
    }

    /* Broken button - hidden until hover */
    .broken-btn {
      position: absolute;
      top: 38px;
      left: 42px;
      background: rgba(0,0,0,0.7);
      border: none;
      color: #8f98a0;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      z-index: 10;
      transition: all 0.2s;
      opacity: 0;
    }
    .game-card:hover .broken-btn {
      opacity: 1;
    }
    .broken-btn:hover {
      background: #ff4444;
      color: #fff;
    }
    .broken-btn.is-broken {
      background: #ff4444;
      color: #fff;
    }

    /* Card rating (clickable 5-star) */
    .card-rating {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0,0,0,0.8);
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
      display: flex;
      gap: 1px;
    }
    .card-rating .star-click {
      cursor: pointer;
      transition: color 0.1s, transform 0.1s;
      padding: 0 1px;
    }
    .card-rating .star-click:hover {
      transform: scale(1.2);
    }
    .card-rating .star-click { color: #444; }
    .card-rating .star-click.filled { color: #666; }
    .card-rating.user-rated .star-click { color: #444; }
    .card-rating.user-rated .star-click.filled { color: #ffd700; }

    /* Star rating component */
    .star-rating {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }
    .star-rating label {
      color: #8f98a0;
      font-size: 13px;
      margin-right: 8px;
      align-self: center;
    }
    .star-rating .stars {
      display: flex;
      gap: 2px;
    }
    .star-rating .star-btn {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #444;
      transition: color 0.1s;
      padding: 0;
    }
    .star-rating .star-btn:hover,
    .star-rating .star-btn.active {
      color: #ffd700;
    }
    .star-rating .star-btn.hovered {
      color: #ffd700;
    }
    .star-rating .clear-btn {
      background: none;
      border: none;
      color: #8f98a0;
      font-size: 11px;
      cursor: pointer;
      margin-left: 8px;
      text-decoration: underline;
    }
    .star-rating .clear-btn:hover {
      color: #fff;
    }
    .variant-selector {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }
    .variant-selector label {
      color: #8f98a0;
      font-size: 13px;
    }
    .variant-selector select {
      background: #1b2838;
      border: 1px solid #4a6572;
      color: #c6d4df;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 13px;
    }

    /* Notes modal */
    .notes-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .notes-modal.active {
      display: flex;
    }
    .notes-content {
      background: #1b2838;
      border: 1px solid #4c6b8a;
      border-radius: 8px;
      width: 500px;
      max-width: 90%;
      max-height: 80vh;
      overflow: hidden;
    }
    .notes-header {
      background: #16202d;
      padding: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #4c6b8a;
    }
    .notes-header h3 {
      color: #fff;
      font-size: 16px;
      font-weight: normal;
    }
    .notes-close {
      background: none;
      border: none;
      color: #8f98a0;
      font-size: 24px;
      cursor: pointer;
    }
    .notes-close:hover {
      color: #fff;
    }
    .notes-body {
      padding: 16px;
    }
    .notes-body textarea {
      width: 100%;
      height: 200px;
      background: #0d1117;
      border: 1px solid #4c6b8a;
      border-radius: 4px;
      color: #c7d5e0;
      padding: 12px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
    }
    .notes-body textarea:focus {
      outline: none;
      border-color: #67c1f5;
    }
    .notes-footer {
      padding: 16px;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      border-top: 1px solid #2a3f5f;
    }
    .notes-save {
      background: linear-gradient(to right, #75b022, #588a1b);
      color: #fff;
      border: none;
      padding: 10px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    .notes-save:hover {
      background: linear-gradient(to right, #8bc53f, #6b9d2a);
    }
    .notes-cancel {
      background: #4c6b8a;
      color: #fff;
      border: none;
      padding: 10px 24px;
      border-radius: 4px;
      cursor: pointer;
    }
    .notes-cancel:hover {
      background: #5a7a9a;
    }

    /* Game Player Modal (game + notes side by side) */
    .player-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 2000;
    }
    .player-modal.active {
      display: flex;
    }
    .player-container {
      display: flex;
      width: 100%;
      height: 100%;
    }
    .player-game {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #000;
      overflow: hidden;
      min-width: 0;
    }
    .iframe-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    .player-header {
      background: #16202d;
      padding: 10px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #4c6b8a;
    }
    .player-title {
      color: #fff;
      font-size: 16px;
    }
    .player-rating {
      display: flex;
      gap: 2px;
      margin: 0 20px;
    }
    .player-star {
      font-size: 24px;
      color: #444;
      cursor: pointer;
      transition: color 0.1s, transform 0.1s;
    }
    .player-star:hover {
      transform: scale(1.2);
    }
    .player-star.filled {
      color: #ffd700;
    }
    .player-actions {
      display: flex;
      gap: 8px;
    }
    .player-btn {
      background: #4c6b8a;
      border: none;
      color: #fff;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .player-btn:hover {
      background: #5a7a9a;
    }
    .player-btn.close-btn {
      background: #c00;
    }
    .player-btn.close-btn:hover {
      background: #e00;
    }
    .player-iframe {
      border: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform-origin: top left;
    }
    .player-notes {
      width: 320px;
      background: #1b2838;
      display: flex;
      flex-direction: column;
      border-left: 1px solid #4c6b8a;
    }
    .player-notes-header {
      background: #16202d;
      padding: 10px 16px;
      border-bottom: 1px solid #4c6b8a;
      color: #67c1f5;
      font-size: 14px;
      font-weight: bold;
    }
    .player-notes-body {
      flex: 1;
      padding: 12px;
      display: flex;
      flex-direction: column;
    }
    .player-notes-body textarea {
      flex: 1;
      background: #0d1117;
      border: 1px solid #4c6b8a;
      border-radius: 4px;
      color: #c7d5e0;
      padding: 12px;
      font-family: inherit;
      font-size: 13px;
      resize: none;
    }
    .player-notes-body textarea:focus {
      outline: none;
      border-color: #67c1f5;
    }
    .player-notes-footer {
      padding: 12px;
      border-top: 1px solid #2a3f5f;
    }
    .player-notes-footer .saved-msg {
      text-align: center;
      color: #a4d007;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .player-notes-footer .saved-msg.show {
      opacity: 1;
    }

    /* Game group headers */
    .game-group-header {
      grid-column: 1 / -1;
      background: linear-gradient(to right, #1e3a50, #16202d);
      padding: 12px 20px;
      border-radius: 4px;
      margin-top: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-left: 4px solid #67c1f5;
    }
    .game-group-header:first-child {
      margin-top: 0;
    }
    .group-name {
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      text-transform: capitalize;
    }
    .group-stats {
      font-size: 12px;
      color: #8f98a0;
    }

    /* Variant tags */
    .tag.variant {
      background: #2a475e;
      color: #67c1f5;
    }
    /* Night tags - different color per night */
    .tag.night-1 {
      background: rgba(76, 175, 80, 0.3);
      color: #81c784;
    }
    .tag.night-2 {
      background: rgba(33, 150, 243, 0.3);
      color: #64b5f6;
    }
    .tag.night-3 {
      background: rgba(156, 39, 176, 0.3);
      color: #ba68c8;
    }
    .tag.night-4 {
      background: rgba(255, 152, 0, 0.3);
      color: #ffb74d;
    }
    /* Hamburger Menu */
    .hamburger-menu {
      position: relative;
      flex-shrink: 0;
    }
    .hamburger-btn {
      background: transparent;
      border: 1px solid #4a6572;
      color: #8f98a0;
      font-size: 18px;
      padding: 6px 10px;
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.15s;
    }
    .hamburger-btn:hover {
      background: #2a475e;
      color: #fff;
      border-color: #67c1f5;
    }
    .menu-dropdown {
      display: none;
      position: absolute;
      right: 0;
      top: 100%;
      background: #1b2838;
      border: 1px solid #4a6572;
      border-radius: 4px;
      min-width: 240px;
      z-index: 1000;
      margin-top: 5px;
    }
    .menu-dropdown.show {
      display: block;
    }
    .menu-dropdown button {
      display: block;
      width: 100%;
      background: none;
      border: none;
      color: #c6d4df;
      padding: 12px 15px;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
    }
    .menu-dropdown button:hover {
      background: #2a475e;
    }
    .menu-dropdown hr {
      border: none;
      border-top: 1px solid #4a6572;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Game Library<span class="version">v2026.01.11d</span></h1>
    <div class="stats-bar">
      <span id="totalGames">0 Games</span>
      <span id="playedGames">0 Played</span>
      <span id="ratedGames" style="color:#ffd700;">Rated 0/0</span>
      <span id="updatedGamesCount" style="color:#ffb74d;">0 Updated</span>
    </div>
    <div class="hamburger-menu">
      <button class="hamburger-btn" onclick="toggleMenu()">‚ò∞</button>
      <div class="menu-dropdown" id="menuDropdown">
        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importNotes(event)">
        <button onclick="document.getElementById('importFile').click()">üì• Import Notes</button>
        <button onclick="exportNotes(); toggleMenu();">üì§ Export Notes</button>
        <hr>
        <button id="markUpdatedMenuBtn" onclick="confirmMarkUpdated()">üîÑ Mark Noted ‚Üí Updated</button>
        <hr>
        <button id="resetUpdatedBtn" onclick="confirmResetUpdated()">‚Ü©Ô∏è Reset Updated ‚Üí Played</button>
        <button id="purgeNotesBtn" onclick="confirmPurgeNotes()" style="color:#ff6b6b;">üóëÔ∏è Purge All Notes</button>
      </div>
    </div>
  </div>

  <div class="controls">
    <div class="control-group">
      <label>Sort</label>
      <select id="sortBy">
        <option value="grouped">By Game</option>
        <option value="final-rating">By Rating</option>
        <option value="date-desc">Recent</option>
        <option value="date-asc">Oldest</option>
        <option value="name">Name</option>
      </select>
    </div>
    <div class="control-group">
      <label>Night</label>
      <select id="filterNight">
        <option value="">All Nights</option>
        <option value="night-1">Night 1</option>
        <option value="night-2">Night 2</option>
        <option value="night-3">Night 3</option>
        <option value="night-4">Night 4</option>
      </select>
    </div>
    <div class="control-group">
      <label>Framework</label>
      <select id="filterFramework">
        <option value="">All</option>
      </select>
    </div>
    <div class="control-group">
      <label>Status</label>
      <select id="filterStatus">
        <option value="">All Games</option>
        <option value="unplayed">Unplayed</option>
        <option value="played">Played</option>
        <option value="polished">Polished</option>
        <option value="has-notes">Has Notes</option>
        <option value="has-rating">Has Rating</option>
        <option value="no-rating">No Rating</option>
        <option value="rating-5">‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ (5)</option>
        <option value="rating-4">‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ (4+)</option>
        <option value="rating-3">‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ (3+)</option>
        <option value="broken">Broken</option>
        <option value="working">Working</option>
      </select>
    </div>
    <div class="control-group">
      <input type="text" id="search" placeholder="Search games...">
    </div>
  </div>

  <div class="content">
    <div class="games-grid" id="gamesGrid"></div>
  </div>

  <!-- Notes Modal -->
  <div class="notes-modal" id="notesModal">
    <div class="notes-content">
      <div class="notes-header">
        <h3 id="notesTitle">Notes</h3>
        <button class="notes-close" onclick="closeNotes()">&times;</button>
      </div>
      <div class="notes-body">
        <div class="star-rating">
          <label>Final Rating:</label>
          <div class="stars" id="modalStars">
            <button class="star-btn" data-rating="1" onclick="setModalRating(1)">‚òÖ</button>
            <button class="star-btn" data-rating="2" onclick="setModalRating(2)">‚òÖ</button>
            <button class="star-btn" data-rating="3" onclick="setModalRating(3)">‚òÖ</button>
            <button class="star-btn" data-rating="4" onclick="setModalRating(4)">‚òÖ</button>
            <button class="star-btn" data-rating="5" onclick="setModalRating(5)">‚òÖ</button>
          </div>
          <button class="clear-btn" onclick="setModalRating(0)">Clear</button>
        </div>
        <div class="variant-selector">
          <label>Status:</label>
          <select id="variantSelect" onchange="setModalVariant(this.value)">
            <option value="">Auto (from data)</option>
            <option value="base">üéÆ Base</option>
            <option value="polished">‚≠ê Polished</option>
            <option value="expanded">üìà Expanded</option>
            <option value="v2">üîÑ V2</option>
          </select>
        </div>
        <textarea id="notesText" placeholder="Add your feedback, bugs found, ideas for improvement..."></textarea>
      </div>
      <div class="notes-footer">
        <button class="notes-cancel" onclick="closeNotes()">Cancel</button>
        <button class="notes-save" onclick="saveNotes()">Save Notes</button>
      </div>
    </div>
  </div>

  <!-- Game Player Modal -->
  <div class="player-modal" id="playerModal">
    <div class="player-container">
      <div class="player-game">
        <div class="player-header">
          <span class="player-title" id="playerTitle">Game Name</span>
          <div class="player-rating" id="playerRating">
            <span class="player-star" onclick="rateFromPlayer(1)">‚òÖ</span>
            <span class="player-star" onclick="rateFromPlayer(2)">‚òÖ</span>
            <span class="player-star" onclick="rateFromPlayer(3)">‚òÖ</span>
            <span class="player-star" onclick="rateFromPlayer(4)">‚òÖ</span>
            <span class="player-star" onclick="rateFromPlayer(5)">‚òÖ</span>
          </div>
          <div class="player-actions">
            <button class="player-btn" onclick="restartGame()" style="background:#c97f00;">‚Üª Restart</button>
            <button class="player-btn" onclick="openInNewTab()">Open in New Tab</button>
            <button class="player-btn" onclick="toggleBrokenFromPlayer()">Mark Broken</button>
            <button class="player-btn close-btn" onclick="closePlayer()">Close (Esc)</button>
          </div>
        </div>
        <div class="iframe-wrapper" id="iframeWrapper">
          <iframe class="player-iframe" id="playerIframe" src="about:blank"></iframe>
        </div>
      </div>
      <div class="player-notes">
        <div class="player-notes-header">üìù Notes</div>
        <div class="player-notes-body">
          <textarea id="playerNotesText" placeholder="Add notes while playing...&#10;&#10;- Bugs found&#10;- Ideas for improvement&#10;- What works well"></textarea>
        </div>
        <div class="player-notes-footer">
          <div class="saved-msg" id="playerSavedMsg">‚úì Saved!</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let allGames = [];
    let playedStatus = JSON.parse(localStorage.getItem('playedGames') || '{}');
    let gameNotes = {};
    let brokenGames = {};
    let finalRatings = {};
    let variantOverrides = {}; // User overrides for Base/Expanded/Polished/V2
    let updatedGames = JSON.parse(localStorage.getItem('updatedGames') || '{}');
    let currentNoteGameId = null;
    let currentPlayerGame = null;
    let savedScrollPosition = 0;
    let notesLoaded = false; // CRITICAL: Prevents saving before notes are loaded

    // Load notes, broken status, and ratings from server (falls back to localStorage)
    async function loadNotes() {
      try {
        const resp = await fetch('/api/notes');
        const data = await resp.json();
        // Support old format (just notes) and new format (notes + broken + ratings)
        if (data._broken) {
          brokenGames = data._broken;
          delete data._broken;
        }
        if (data._ratings) {
          finalRatings = data._ratings;
          delete data._ratings;
        }
        gameNotes = data;
      } catch (e) {
        gameNotes = JSON.parse(localStorage.getItem('gameNotes') || '{}');
        brokenGames = JSON.parse(localStorage.getItem('brokenGames') || '{}');
        finalRatings = JSON.parse(localStorage.getItem('finalRatings') || '{}');
        variantOverrides = JSON.parse(localStorage.getItem('variantOverrides') || '{}');
      }
      notesLoaded = true; // CRITICAL: Mark notes as loaded
      console.log('[Notes] Loaded', Object.keys(gameNotes).length, 'notes from storage');
    }

    async function toggleBroken(e, gameId) {
      e.stopPropagation();
      if (brokenGames[gameId]) {
        delete brokenGames[gameId];
      } else {
        brokenGames[gameId] = true;
        // Broken = 0 points, clear any rating
        delete finalRatings[gameId];
      }
      await saveData();
      renderGames();
    }

    async function saveData() {
      // CRITICAL: Never save if notes haven't been loaded yet - prevents data wipe!
      if (!notesLoaded) {
        console.error('[Notes] BLOCKED save attempt before notes loaded! This would have wiped data.');
        return;
      }
      // Always save to localStorage first (GitHub Pages has no backend)
      localStorage.setItem('gameNotes', JSON.stringify(gameNotes));
      localStorage.setItem('brokenGames', JSON.stringify(brokenGames));
      localStorage.setItem('finalRatings', JSON.stringify(finalRatings));
      localStorage.setItem('variantOverrides', JSON.stringify(variantOverrides));
      console.log('[Notes] Saved', Object.keys(gameNotes).length, 'notes to storage');
      // Try server API if available (for local dev)
      try {
        const resp = await fetch('/api/notes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ...gameNotes, _broken: brokenGames, _ratings: finalRatings, _variants: variantOverrides })
        });
        if (!resp.ok) throw new Error('API not available');
      } catch (e) {
        // Silently ignore - localStorage already saved
      }
    }

    async function loadGames() {
      try {
        await loadNotes();
        const resp = await fetch('games-index.json?t=' + Date.now());
        allGames = await resp.json();
        allGames.forEach(g => g.played = !!playedStatus[g.id]);
        populateFilters();
        restoreFilters(); // Restore AFTER filters are populated
        renderGames();
        restorePlayingGame(); // Reopen game if ?playing= in URL
      } catch (e) {
        document.getElementById('gamesGrid').innerHTML = '<p style="color:#c00;padding:20px;">Error loading games</p>';
      }
    }

    function restorePlayingGame() {
      const urlParams = new URLSearchParams(window.location.search);
      const playingId = urlParams.get('playing');
      if (playingId) {
        const game = allGames.find(g => g.id === playingId);
        if (game) {
          // Save current scroll position
          savedScrollPosition = window.scrollY;
          // Open the game without pushing new history state
          currentPlayerGame = { id: game.id, path: game.path, game: game };
          document.getElementById('playerTitle').textContent = game.name;
          document.getElementById('playerIframe').src = game.path;
          document.getElementById('playerNotesText').value = gameNotes[game.id] || '';
          document.getElementById('playerModal').classList.add('active');
          document.body.style.overflow = 'hidden';
          setTimeout(() => {
            scaleIframeToFit();
            updatePlayerRatingStars();
          }, 100);
          // Replace current history state instead of pushing
          history.replaceState({ playing: true, gameId: game.id }, '', '?playing=' + game.id);
        }
      }
    }

    function populateFilters() {
      const frameworks = [...new Set(allGames.map(g => g.framework))].sort();
      const select = document.getElementById('filterFramework');
      frameworks.forEach(f => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });
    }

    function getFilteredGames() {
      let games = [...allGames];
      const search = document.getElementById('search').value.toLowerCase();
      const night = document.getElementById('filterNight').value;
      const framework = document.getElementById('filterFramework').value;
      const status = document.getElementById('filterStatus').value;
      const sortBy = document.getElementById('sortBy').value;

      if (search) games = games.filter(g => g.name.toLowerCase().includes(search) || g.gameDir.toLowerCase().includes(search));
      if (night) games = games.filter(g => g.night === night);
      if (framework) games = games.filter(g => g.framework === framework);
      if (status === 'unplayed') games = games.filter(g => !g.played);
      else if (status === 'played') games = games.filter(g => g.played);
      else if (status === 'polished') games = games.filter(g => g.polished);
      else if (status === 'has-notes') games = games.filter(g => gameNotes[g.id]);
      else if (status === 'has-rating') games = games.filter(g => finalRatings[g.id]);
      else if (status === 'no-rating') games = games.filter(g => !finalRatings[g.id]);
      else if (status === 'rating-5') games = games.filter(g => finalRatings[g.id] === 5);
      else if (status === 'rating-4') games = games.filter(g => finalRatings[g.id] >= 4);
      else if (status === 'rating-3') games = games.filter(g => finalRatings[g.id] >= 3);
      else if (status === 'broken') games = games.filter(g => brokenGames[g.id]);
      else if (status === 'working') games = games.filter(g => !brokenGames[g.id]);

      switch (sortBy) {
        case 'date-asc': games.sort((a, b) => new Date(a.createdDate) - new Date(b.createdDate)); break;
        case 'name': games.sort((a, b) => a.name.localeCompare(b.name)); break;
        case 'final-rating': games.sort((a, b) => (finalRatings[b.id] || 0) - (finalRatings[a.id] || 0)); break;
        case 'grouped': games.sort((a, b) => {
          // Extract base game name (without -expanded, -polished, -v2)
          const getBase = (g) => g.gameDir.replace(/-expanded$|-polished$|-v2$/, '');
          const getVariant = (g) => {
            if (g.gameDir.includes('-polished')) return 2;
            if (g.gameDir.includes('-expanded')) return 1;
            if (g.gameDir.includes('-v2')) return 3;
            return 0; // base
          };
          const baseA = getBase(a);
          const baseB = getBase(b);
          if (baseA !== baseB) return baseA.localeCompare(baseB);
          // Same base game - sort by variant (base, expanded, polished)
          const varA = getVariant(a);
          const varB = getVariant(b);
          if (varA !== varB) return varA - varB;
          // Same variant - sort by framework
          return a.framework.localeCompare(b.framework);
        }); break;
        default: games.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
      }
      return games;
    }

    function playGame(gameId, path) {
      playedStatus[gameId] = Date.now();
      localStorage.setItem('playedGames', JSON.stringify(playedStatus));
      const game = allGames.find(g => g.id === gameId);
      if (game) game.played = true;

      // Save scroll position before opening modal
      savedScrollPosition = window.scrollY;

      // Open in player modal with notes panel
      currentPlayerGame = { id: gameId, path: path, game: game };
      document.getElementById('playerTitle').textContent = game ? game.name : 'Game';
      document.getElementById('playerIframe').src = path;
      document.getElementById('playerNotesText').value = gameNotes[gameId] || '';
      document.getElementById('playerModal').classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent background scroll

      // Scale iframe and update rating display
      setTimeout(() => {
        scaleIframeToFit();
        updatePlayerRatingStars();
      }, 100);

      // Push history state so back button closes modal
      history.pushState({ playing: true, gameId: gameId }, '', '?playing=' + gameId);

      renderGames();
    }

    // Scale iframe to fit wrapper (assumes common game resolution)
    function scaleIframeToFit() {
      const wrapper = document.getElementById('iframeWrapper');
      const iframe = document.getElementById('playerIframe');
      if (!wrapper || !iframe) return;

      const wrapperW = wrapper.clientWidth;
      const wrapperH = wrapper.clientHeight;

      // Assume games target ~800x600 or similar - use wrapper size as iframe size
      // and let the game scale inside. Most canvas games auto-fit.
      // For games that don't, we set iframe larger and scale down.
      const gameW = 1024;
      const gameH = 768;

      const scaleX = wrapperW / gameW;
      const scaleY = wrapperH / gameH;
      const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down

      if (scale < 1) {
        iframe.style.width = gameW + 'px';
        iframe.style.height = gameH + 'px';
        iframe.style.transform = `scale(${scale})`;
      } else {
        // Fits fine, use 100%
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.transform = 'none';
      }
    }

    // Re-scale on window resize
    window.addEventListener('resize', () => {
      if (document.getElementById('playerModal').classList.contains('active')) {
        scaleIframeToFit();
      }
    });

    function closePlayer() {
      // Auto-save notes before closing
      if (currentPlayerGame) {
        const text = document.getElementById('playerNotesText').value.trim();
        if (text) {
          gameNotes[currentPlayerGame.id] = text;
        } else {
          delete gameNotes[currentPlayerGame.id];
        }
        saveData();
        renderGames();
      }

      document.getElementById('playerModal').classList.remove('active');
      document.getElementById('playerIframe').src = 'about:blank';
      document.body.style.overflow = ''; // Restore scrolling
      currentPlayerGame = null;

      // Go back in history if we pushed a state
      if (history.state && history.state.playing) {
        history.back();
      }

      // Restore scroll position after a brief delay
      setTimeout(() => window.scrollTo(0, savedScrollPosition), 50);
    }

    // Handle browser back button
    window.addEventListener('popstate', function(e) {
      if (document.getElementById('playerModal').classList.contains('active')) {
        // Auto-save notes before closing
        if (currentPlayerGame) {
          const text = document.getElementById('playerNotesText').value.trim();
          if (text) {
            gameNotes[currentPlayerGame.id] = text;
          } else {
            delete gameNotes[currentPlayerGame.id];
          }
          saveData();
          renderGames();
        }
        document.body.style.overflow = ''; // Restore scrolling
        setTimeout(() => window.scrollTo(0, savedScrollPosition), 50);
        document.getElementById('playerModal').classList.remove('active');
        document.getElementById('playerIframe').src = 'about:blank';
        currentPlayerGame = null;
      }
    });
    
    // Block ALL keyboard scrolling when player modal is open (capture phase)
    window.addEventListener('keydown', function(e) {
      const playerOpen = document.getElementById('playerModal').classList.contains('active');

      if (playerOpen && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'PageUp', 'PageDown', 'Home', 'End'].includes(e.key)) {
        // Only allow if typing in notes textarea
        if (document.activeElement?.id !== 'playerNotesText') {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }
    }, { capture: true });

    // Handle Escape key to close modals
    document.addEventListener('keydown', function(e) {
      const playerOpen = document.getElementById('playerModal').classList.contains('active');
      const notesOpen = document.getElementById('notesModal').classList.contains('active');

      if (e.key === 'Escape') {
        if (playerOpen) {
          closePlayer();
        } else if (notesOpen) {
          closeNotes();
        }
      }
    });

    function openInNewTab() {
      if (currentPlayerGame) {
        window.open(currentPlayerGame.path, '_blank');
      }
    }

    function restartGame() {
      if (currentPlayerGame) {
        const iframe = document.getElementById('playerIframe');
        iframe.src = 'about:blank';
        setTimeout(() => { iframe.src = currentPlayerGame.path; }, 50);
      }
    }

    async function savePlayerNotes(showMessage = true) {
      if (!currentPlayerGame) return;
      const text = document.getElementById('playerNotesText').value.trim();
      if (text) {
        gameNotes[currentPlayerGame.id] = text;
      } else {
        delete gameNotes[currentPlayerGame.id];
      }
      await saveData();
      renderGames();
      // Show saved message
      if (showMessage) {
        const msg = document.getElementById('playerSavedMsg');
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), 2000);
      }
    }

    // Auto-save notes with debounce
    let autoSaveTimeout = null;
    document.getElementById('playerNotesText').addEventListener('input', function() {
      // Clear previous timeout
      if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
      // Show "saving..." indicator
      document.getElementById('playerSavedMsg').textContent = 'Saving...';
      document.getElementById('playerSavedMsg').classList.add('show');
      // Save after 1 second of no typing
      autoSaveTimeout = setTimeout(async () => {
        await savePlayerNotes(false);
        document.getElementById('playerSavedMsg').textContent = '‚úì Saved!';
        setTimeout(() => {
          document.getElementById('playerSavedMsg').classList.remove('show');
          document.getElementById('playerSavedMsg').textContent = '‚úì Saved!';
        }, 1500);
      }, 1000);
    });

    async function toggleBrokenFromPlayer() {
      if (!currentPlayerGame) return;
      if (brokenGames[currentPlayerGame.id]) {
        delete brokenGames[currentPlayerGame.id];
      } else {
        brokenGames[currentPlayerGame.id] = true;
        // Broken = 0 points, clear any rating
        delete finalRatings[currentPlayerGame.id];
      }
      await saveData();
      renderGames();
      updatePlayerRatingStars();
    }

    // Rate game from player modal
    async function rateFromPlayer(rating) {
      if (!currentPlayerGame) return;
      // Toggle off if clicking same rating
      if (finalRatings[currentPlayerGame.id] === rating) {
        delete finalRatings[currentPlayerGame.id];
      } else {
        finalRatings[currentPlayerGame.id] = rating;
        // Unmark as broken if rating
        delete brokenGames[currentPlayerGame.id];
      }
      await saveData();
      renderGames();
      updatePlayerRatingStars();
    }

    // Update player modal rating stars display
    function updatePlayerRatingStars() {
      if (!currentPlayerGame) return;
      const rating = finalRatings[currentPlayerGame.id] || 0;
      const stars = document.querySelectorAll('.player-star');
      stars.forEach((star, i) => {
        star.classList.toggle('filled', i < rating);
      });
    }

    let currentModalRating = 0;

    let currentModalVariant = '';

    function openNotes(e, gameId, gameName) {
      e.stopPropagation();
      currentNoteGameId = gameId;
      currentModalRating = finalRatings[gameId] || 0;
      currentModalVariant = variantOverrides[gameId] || '';
      document.getElementById('notesTitle').textContent = 'Notes: ' + gameName;
      document.getElementById('notesText').value = gameNotes[gameId] || '';
      document.getElementById('variantSelect').value = currentModalVariant;
      updateModalStars();
      document.getElementById('notesModal').classList.add('active');
      document.getElementById('notesText').focus();
    }

    function setModalRating(rating) {
      currentModalRating = rating;
      updateModalStars();
    }

    // Rate game directly from card
    async function rateGame(e, gameId, rating) {
      e.stopPropagation();
      // Toggle off if clicking same rating
      if (finalRatings[gameId] === rating) {
        delete finalRatings[gameId];
      } else {
        finalRatings[gameId] = rating;
      }
      await saveData();
      renderGames();
    }

    function setModalVariant(variant) {
      currentModalVariant = variant;
    }

    function updateModalStars() {
      const stars = document.querySelectorAll('#modalStars .star-btn');
      stars.forEach((star, i) => {
        star.classList.toggle('active', i < currentModalRating);
      });
    }

    function closeNotes() {
      document.getElementById('notesModal').classList.remove('active');
      currentNoteGameId = null;
      currentModalRating = 0;
    }

    async function saveNotes() {
      const text = document.getElementById('notesText').value.trim();
      if (text) {
        gameNotes[currentNoteGameId] = text;
      } else {
        delete gameNotes[currentNoteGameId];
      }
      // Save rating
      if (currentModalRating > 0) {
        finalRatings[currentNoteGameId] = currentModalRating;
      } else {
        delete finalRatings[currentNoteGameId];
      }
      // Save variant override
      if (currentModalVariant) {
        variantOverrides[currentNoteGameId] = currentModalVariant;
      } else {
        delete variantOverrides[currentNoteGameId];
      }
      await saveData();
      closeNotes();
      renderGames();
    }

    // Note: Escape key handling is done in the popstate/escape listener above

    // Hamburger menu toggle
    function toggleMenu() {
      const dropdown = document.getElementById('menuDropdown');
      dropdown.classList.toggle('show');
    }

    // Close menu when clicking outside
    document.addEventListener('click', function(e) {
      const menu = document.querySelector('.hamburger-menu');
      if (menu && !menu.contains(e.target)) {
        document.getElementById('menuDropdown').classList.remove('show');
      }
    });

    // Import notes from JSON file
    function importNotes(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          let imported = 0;

          // Handle game-status.json format (has games array)
          if (data.games && Array.isArray(data.games)) {
            data.games.forEach(g => {
              if (g.notes) { gameNotes[g.id] = g.notes; imported++; }
              if (g.broken) { brokenGames[g.id] = true; }
              if (g.finalRating) { finalRatings[g.id] = g.finalRating; }
              if (g.variantOverride) { variantOverrides[g.id] = g.variantOverride; }
            });
            // Also import variantOverrides object if present
            if (data.variantOverrides) {
              Object.assign(variantOverrides, data.variantOverrides);
            }
          }
          // Handle direct localStorage format
          else if (typeof data === 'object') {
            // Check if it's gameNotes format (id -> string)
            Object.keys(data).forEach(key => {
              if (typeof data[key] === 'string') {
                gameNotes[key] = data[key];
                imported++;
              }
            });
          }

          saveData();
          renderGames();
          toggleMenu();
          alert('Imported ' + imported + ' notes successfully!');
        } catch (err) {
          alert('Error importing file: ' + err.message);
        }
      };
      reader.readAsText(file);
      event.target.value = ''; // Reset file input
    }

    function exportNotes() {
      const exportData = { games: [], broken: [], rated: [], summary: {} };

      // All games with notes, broken status, final rating, or variant override
      allGames.forEach(g => {
        const hasNotes = gameNotes[g.id];
        const isBroken = brokenGames[g.id];
        const rating = finalRatings[g.id];
        const variant = variantOverrides[g.id];
        if (hasNotes || isBroken || rating || variant) {
          exportData.games.push({
            id: g.id,
            name: g.name,
            framework: g.framework,
            path: g.path,
            broken: isBroken || false,
            finalRating: rating || null,
            variantOverride: variant || null,
            notes: hasNotes || ''
          });
        }
        if (isBroken) exportData.broken.push(g.id);
        if (rating) exportData.rated.push({ id: g.id, rating });
      });

      // Add variant overrides summary
      exportData.variantOverrides = { ...variantOverrides };

      // Sort rated by rating descending
      exportData.rated.sort((a, b) => b.rating - a.rating);

      exportData.summary = {
        total: allGames.length,
        broken: Object.keys(brokenGames).length,
        working: allGames.length - Object.keys(brokenGames).length,
        withNotes: Object.keys(gameNotes).length,
        withRating: Object.keys(finalRatings).length,
        avgRating: Object.keys(finalRatings).length > 0
          ? (Object.values(finalRatings).reduce((a,b) => a+b, 0) / Object.keys(finalRatings).length).toFixed(1)
          : null,
        ratingBreakdown: {
          '5': Object.values(finalRatings).filter(r => r === 5).length,
          '4': Object.values(finalRatings).filter(r => r === 4).length,
          '3': Object.values(finalRatings).filter(r => r === 3).length,
          '2': Object.values(finalRatings).filter(r => r === 2).length,
          '1': Object.values(finalRatings).filter(r => r === 1).length
        }
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'game-status.json';
      a.click();
    }

    // Confirmation state for mark updated button
    let markUpdatedPending = false;
    let markUpdatedTimeout = null;

    function confirmMarkUpdated() {
      const btn = document.getElementById('markUpdatedMenuBtn');
      const noteCount = Object.keys(gameNotes).length;

      if (noteCount === 0) {
        btn.textContent = 'No notes to clear!';
        btn.style.background = '#666';
        setTimeout(() => {
          btn.textContent = 'Mark Noted ‚Üí Updated';
          btn.style.background = '#c97f00';
        }, 2000);
        return;
      }

      if (!markUpdatedPending) {
        markUpdatedPending = true;
        btn.textContent = `Confirm? (${noteCount} games)`;
        btn.style.background = '#cc0000';
        markUpdatedTimeout = setTimeout(() => {
          markUpdatedPending = false;
          btn.textContent = 'Mark Noted ‚Üí Updated';
          btn.style.background = '#c97f00';
        }, 3000);
      } else {
        clearTimeout(markUpdatedTimeout);
        markUpdatedPending = false;
        markAllNotedAsUpdated();
        btn.textContent = 'Done!';
        btn.style.background = '#4c6b22';
        setTimeout(() => {
          btn.textContent = 'Mark Noted ‚Üí Updated';
          btn.style.background = '#c97f00';
        }, 2000);
      }
    }

    // Purge all notes with confirmation
    let purgeNotesPending = false;
    let purgeNotesTimeout = null;

    function confirmPurgeNotes() {
      const btn = document.getElementById('purgeNotesBtn');
      const noteCount = Object.keys(gameNotes).length;

      if (noteCount === 0) {
        btn.textContent = 'No notes to purge!';
        btn.style.background = '#666';
        setTimeout(() => {
          btn.textContent = 'üóëÔ∏è Purge All Notes';
          btn.style.background = '';
        }, 2000);
        return;
      }

      if (!purgeNotesPending) {
        purgeNotesPending = true;
        btn.textContent = `‚ö†Ô∏è CONFIRM DELETE ${noteCount} NOTES?`;
        btn.style.background = '#cc0000';
        purgeNotesTimeout = setTimeout(() => {
          purgeNotesPending = false;
          btn.textContent = 'üóëÔ∏è Purge All Notes';
          btn.style.background = '';
        }, 3000);
      } else {
        clearTimeout(purgeNotesTimeout);
        purgeNotesPending = false;
        // Actually purge all notes
        const count = Object.keys(gameNotes).length;
        gameNotes = {};
        saveData();
        renderGames();
        btn.textContent = `‚úì Purged ${count} notes!`;
        btn.style.background = '#4c6b22';
        setTimeout(() => {
          btn.textContent = 'üóëÔ∏è Purge All Notes';
          btn.style.background = '';
          toggleMenu();
        }, 2000);
      }
    }

    // Reset all updated games back to played
    let resetUpdatedPending = false;
    let resetUpdatedTimeout = null;

    function confirmResetUpdated() {
      const btn = document.getElementById('resetUpdatedBtn');
      const updatedCount = Object.keys(updatedGames).length;

      if (updatedCount === 0) {
        btn.textContent = 'No updated games!';
        btn.style.background = '#666';
        setTimeout(() => {
          btn.textContent = '‚Ü©Ô∏è Reset Updated ‚Üí Played';
          btn.style.background = '';
        }, 2000);
        return;
      }

      if (!resetUpdatedPending) {
        resetUpdatedPending = true;
        btn.textContent = `Confirm? (${updatedCount} games)`;
        btn.style.background = '#cc0000';
        resetUpdatedTimeout = setTimeout(() => {
          resetUpdatedPending = false;
          btn.textContent = '‚Ü©Ô∏è Reset Updated ‚Üí Played';
          btn.style.background = '';
        }, 3000);
      } else {
        clearTimeout(resetUpdatedTimeout);
        resetUpdatedPending = false;
        // Clear all updated status
        updatedGames = {};
        localStorage.setItem('updatedGames', JSON.stringify(updatedGames));
        renderGames();
        btn.textContent = `‚úì Reset ${updatedCount} games!`;
        btn.style.background = '#4c6b22';
        setTimeout(() => {
          btn.textContent = '‚Ü©Ô∏è Reset Updated ‚Üí Played';
          btn.style.background = '';
          toggleMenu();
        }, 2000);
      }
    }

    // Mark games as updated (call from console: markUpdated(['game-id-1', 'game-id-2']))
    // Also clears notes for those games by default
    window.markUpdated = function(gameIds, clearNotes = true) {
      const now = Date.now();
      let updated = 0;
      let cleared = 0;
      gameIds.forEach(id => {
        updatedGames[id] = now;
        updated++;
        if (clearNotes && gameNotes[id]) {
          delete gameNotes[id];
          cleared++;
        }
      });
      localStorage.setItem('updatedGames', JSON.stringify(updatedGames));
      if (clearNotes) saveData();
      renderGames();
      console.log(`‚úÖ Marked ${updated} games as updated, cleared ${cleared} notes`);
      return { updated, cleared };
    };

    // Mark ALL games with notes as updated (clears all notes)
    window.markAllNotedAsUpdated = function() {
      const ids = Object.keys(gameNotes);
      return markUpdated(ids, true);
    };

    // Clear notes for specific games without marking as updated
    window.clearNotes = function(gameIds) {
      let cleared = 0;
      gameIds.forEach(id => {
        if (gameNotes[id]) {
          delete gameNotes[id];
          cleared++;
        }
      });
      saveData();
      renderGames();
      console.log(`‚úÖ Cleared ${cleared} notes`);
      return cleared;
    };

    // Get list of games with notes (for piping to markUpdated)
    window.getGamesWithNotes = function() {
      const ids = Object.keys(gameNotes);
      console.log(`Games with notes (${ids.length}):`, ids);
      return ids;
    };

    // Check if game should show "updated" badge
    function isGameUpdated(gameId) {
      const updateTime = updatedGames[gameId];
      const playTime = playedStatus[gameId];
      // Show "updated" if: game was updated AND (never played OR played before update)
      return updateTime && (!playTime || updateTime > playTime);
    }

    function renderGames() {
      const games = getFilteredGames();
      const sortBy = document.getElementById('sortBy').value;
      document.getElementById('totalGames').textContent = allGames.length + ' Games';
      document.getElementById('playedGames').textContent = allGames.filter(g => g.played).length + ' Played';
      const ratedCount = new Set([...Object.keys(finalRatings), ...Object.keys(brokenGames)]).size;
      document.getElementById('ratedGames').textContent = 'Rated ' + ratedCount + '/' + allGames.length;
      document.getElementById('updatedGamesCount').textContent = allGames.filter(g => isGameUpdated(g.id)).length + ' Updated';

      const getBase = (g) => g.gameDir.replace(/-expanded$|-polished$|-v2$/, '');
      const getVariantLabel = (g) => {
        // Check for user override first
        const override = variantOverrides[g.id];
        if (override === 'polished') return '‚≠ê Polished';
        if (override === 'expanded') return 'üìà Expanded';
        if (override === 'v2') return 'üîÑ V2';
        if (override === 'base') return 'üéÆ Base';
        // Fall back to auto-detection
        if (g.polished) return '‚≠ê Polished';
        if (g.gameDir.includes('-expanded')) return 'üìà Expanded';
        if (g.gameDir.includes('-v2')) return 'üîÑ V2';
        return 'üéÆ Base';
      };

      let html = '';
      let lastBase = '';

      games.forEach((g, i) => {
        const base = getBase(g);
        // Add section header when game group changes (only in grouped mode)
        if (sortBy === 'grouped' && base !== lastBase) {
          const baseName = base.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
          const groupGames = games.filter(gg => getBase(gg) === base);
          const workingCount = groupGames.filter(gg => !brokenGames[gg.id]).length;
          const brokenCount = groupGames.filter(gg => brokenGames[gg.id]).length;
          html += `<div class="game-group-header">
            <span class="group-name">${baseName}</span>
            <span class="group-stats">${groupGames.length} versions (${workingCount} working, ${brokenCount} broken)</span>
          </div>`;
          lastBase = base;
        }

        const variantLabel = sortBy === 'grouped' ? getVariantLabel(g) : '';

        const isBroken = brokenGames[g.id];
        const userRating = isBroken ? 0 : (finalRatings[g.id] || 0);

        html += `
        <div class="game-card ${g.played && !isGameUpdated(g.id) ? 'played' : ''} ${isGameUpdated(g.id) ? 'updated' : ''} ${isBroken ? 'broken' : ''}" onclick="playGame('${g.id}', '${g.path}')">
          <button class="notes-btn ${gameNotes[g.id] ? 'has-notes' : ''}" onclick="openNotes(event, '${g.id}', '${g.name.replace(/'/g, "\\'")}')">üìù</button>
          <button class="broken-btn ${isBroken ? 'is-broken' : ''}" onclick="toggleBroken(event, '${g.id}')" title="Mark as broken">‚úï</button>
          ${!isBroken ? `<div class="card-rating ${userRating > 0 ? 'user-rated' : ''}" onclick="event.stopPropagation()">
            ${[1,2,3,4,5].map(n => `<span class="star-click ${n <= userRating ? 'filled' : 'empty'}" onclick="rateGame(event, '${g.id}', ${n})">‚òÖ</span>`).join('')}
          </div>` : ''}
          ${g.screenshot
            ? `<img class="screenshot" src="${g.path}${g.screenshot}" alt="${g.name}" onerror="this.outerHTML='<div class=no-screenshot>üéÆ</div>'">`
            : '<div class="no-screenshot">üéÆ</div>'
          }
          <div class="card-info">
            <div class="game-title">${g.name}</div>
            <div class="game-tags">
              <span class="tag ${g.night}">${g.night.replace('night-', 'Night ')}</span>
              <span class="tag framework">${g.framework}</span>
              ${variantLabel ? `<span class="tag variant">${variantLabel}</span>` : ''}
              ${g.polished && !variantLabel ? '<span class="tag polished">Polished</span>' : ''}
            </div>
          </div>
        </div>`;
      });

      // Show empty state if no games match filters
      if (games.length === 0) {
        const night = document.getElementById('filterNight').value;
        const framework = document.getElementById('filterFramework').value;
        const status = document.getElementById('filterStatus').value;
        const search = document.getElementById('search').value;

        let msg = 'No games found';
        const parts = [];
        if (framework) parts.push(framework);
        if (night) parts.push(night.replace('night-', 'Night '));
        if (status) parts.push(status);
        if (search) parts.push(`matching "${search}"`);
        if (parts.length) msg += ': ' + parts.join(' + ');

        html = `<div style="grid-column: 1/-1; text-align: center; padding: 60px 20px; color: #8f98a0;">
          <div style="font-size: 48px; margin-bottom: 20px;">üéÆ</div>
          <div style="font-size: 18px; margin-bottom: 10px;">${msg}</div>
          <div style="font-size: 13px;">Try adjusting your filters</div>
        </div>`;
      }

      document.getElementById('gamesGrid').innerHTML = html;
    }

    // Persist filters to localStorage AND URL
    const filterIds = ['sortBy', 'filterNight', 'filterFramework', 'filterStatus', 'search'];
    const urlParamMap = { sortBy: 'sort', filterNight: 'night', filterFramework: 'framework', filterStatus: 'status', search: 'q' };

    function saveFilters() {
      const filters = {};
      filterIds.forEach(id => filters[id] = document.getElementById(id).value);
      localStorage.setItem('gameFilters', JSON.stringify(filters));
      updateURL();
    }

    function updateURL() {
      const params = new URLSearchParams();
      filterIds.forEach(id => {
        const val = document.getElementById(id).value;
        if (val) params.set(urlParamMap[id], val);
      });
      const newURL = params.toString() ? '?' + params.toString() : window.location.pathname;
      history.replaceState(null, '', newURL);
    }

    function restoreFilters() {
      // URL params take priority over localStorage
      const urlParams = new URLSearchParams(window.location.search);
      const hasURLParams = urlParams.toString().length > 0;

      if (hasURLParams) {
        filterIds.forEach(id => {
          const urlKey = urlParamMap[id];
          if (urlParams.has(urlKey)) {
            document.getElementById(id).value = urlParams.get(urlKey);
          }
        });
      } else {
        try {
          const filters = JSON.parse(localStorage.getItem('gameFilters') || '{}');
          filterIds.forEach(id => {
            if (filters[id]) document.getElementById(id).value = filters[id];
          });
        } catch(e) {}
      }
    }

    function onFilterChange() {
      saveFilters();
      renderGames();
    }

    document.getElementById('sortBy').addEventListener('change', onFilterChange);
    document.getElementById('filterNight').addEventListener('change', onFilterChange);
    document.getElementById('filterFramework').addEventListener('change', onFilterChange);
    document.getElementById('filterStatus').addEventListener('change', onFilterChange);
    document.getElementById('search').addEventListener('input', onFilterChange);

    loadGames(); // restoreFilters() is called inside after populateFilters()
  </script>
</body>
</html>
<!-- deploy 034137 -->
